extends c

##
## Preprocessor
# #include <...>
snippet incb
	#include <boost/${1:boost}.hpp>
snippet cpp
	#include <iostream>

	using namespace std;

	int main(int argc, char *argv[]) {
		${1}

		return 0;
	}
##
## STL Collections
# std::array
snippet array
	std::array<${1:T}, ${2:N}> ${3:M};
# std::vector
snippet vector
	std::vector<${1:T}> ${2:N};
# std::deque
snippet deque
	std::deque<${1:T}> ${2:V};
# std::forward_list
snippet flist
	std::forward_list<${1:T}> ${2:V};
# std::list
snippet list
	std::list<${1:T}> ${2:V};
# std::set
snippet set
	std::set<${1:T}> ${2:V};
# std::map
snippet map
	std::map<${1:Key}, ${2:T}> ${3:N};
# std::multiset
snippet mset
	std::multiset<${1:T}> ${2:V};
# std::multimap
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3:N};
# std::unordered_set
snippet uset
	std::unordered_set<${1:T}> ${2:V};
# std::unordered_map
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3:N};
# std::unordered_multiset
snippet umset
	std::unordered_multiset<${1:T}> ${2:V};
# std::unordered_multimap
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3:N};
# std::stack
snippet stack
	std::stack<${1:T}> ${2:V};
# std::queue
snippet queue
	std::queue<${1:T}> ${2:V};
# std::priority_queue
snippet pqueue
	std::priority_queue<${1:T}> ${2:V};
##
## STL smart pointers
# std::shared_ptr
snippet sp
	std::shared_ptr<${1:T}>
snippet msp
	std::make_shared<${1:T}>(${2:V});
snippet amsp
	auto ${1:T} = std::make_shared<${2:V}>(${3:N});
# std::unique_ptr
snippet up
	std::unique_ptr<${1:T}>
snippet mup
	std::make_unique<${1:T}>(${2:V});
snippet amup
	auto ${1:T} = std::make_unique<${2:T}>(${3:N});
##
## Access Modifiers
# private
snippet pri
	private:
	  ${1:P}
# protected
snippet pro
	protected:
	  ${1:P}
# public
snippet pub
	public:
	  ${1:M}
# friend
snippet fr
	friend:
	  ${1:F}
# mutable
snippet mu
	mutable
##
snippet comment
	/**
	 * ${1: subject}.
	 *
	 * ${2: detailed info}.
	 *
	 * ${3: @param @return lines}.
	 */
## Class
# class
snippet cl
	class ${1}
	{
	  ${2:P}
	};
# member function implementation
snippet mfun
	${4:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:N}) {
		${0}
	}
# member function implementation without parameters
snippet dmfun0
	${3:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}() {
		${0}
	}
# member function implementation with one parameter
snippet dmfun1
	${5:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter}) {
		${0}
	}
# member function implementation with two parameter
snippet dmfun2
	${7:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter},${5:Type} ${6:Parameter}) {
		${0}
	}
# namespace
snippet ns
	namespace ${1:`vim_snippets#Filename('', 'my')`} {
		${0}
	} /* namespace $1 */
snippet ans
	namespace {
		${0}
	}
##
# std::
snippet using
	using namespace std;
snippet std
	std::
## Input/Output
# std::cout
snippet cout
	std::cout << ${1:T} << '\n';
snippet coutn
	std::cout << '\n';
# std::cin
snippet cin
	std::cin >> ${1:T};
# std::endl
snippet endl
	std::endl;
snippet cco
	for(auto& i: ${1:C}) {
		std::cout << i << ' ';
	}
	std::cout << '\n';
snippet ccm
	for(auto& [k,v]:${1:pair}) {
		std::cout << k << " : " << v << '\n';
	}
snippet thread
	std::thread ${1:th};
snippet threadf
	std::thread(${1:F,args});
snippet mutex
	std::mutex ${1:m};
snippet lockg
	std::lock_guard<std::mutex> lock(${1:mraii});
snippet ulock
	std::unique_lock<std::mutex> lock(${1:mraii});
snippet atomic
	std::atomic<int> ${1:count};
##
## Casts
# static
snippet sca
	static_cast<${1:unsigned}>(${2:expr});
# dynamic
snippet dca
	dynamic_cast<${1:unsigned}>(${2:expr});
# reinterpret
#	reinterpret_cast<${1:unsigned}>(${2:expr})${3:N}
snippet rca
	reinterpret_cast<${1:unsigned}>(${2:expr});
# const
snippet cca
	const_cast<${1:unsigned}>(${2:expr});
snippet aca
	std::any_cast<${1:type}>(${2:val})
## Iteration
# for integer
snippet fori
	for (int i = 0; i < ${1:count}; ++i) {
		${2}
	}
# for size_t
snippet fors
	for (size_t i = 0; i < ${1:count}; ++i) {
		${2}
	}
# foreach
snippet fore
	for (${1:const auto& elem} : ${2:container}) {
		${3}
	}
# iterator
snippet forit
	for (auto& it = ${1:container}.begin(); it != $1.end(); ++it) {
		${2:std::cout << *it << '\n';}
	}
# begin-end similar to ranges
snippet beg
	${1:v}.begin(),$1.end(),${2}
##
## Lambdas
# lamda (one line)
snippet ld
	[${1:T}](${2:V}){${3:N}}
# lambda (multi-line)
snippet lld
	[${1:T}](${2:V}){
		${3:N}
	};
# snippets exception
snippet try
	try {

	}catch(${1:T}) {

	}
# auto function
snippet af auto function
	auto ${1:name}(${2:V})
	{
		${0}
	};
snippet string
	std::string
snippet distance
	std::distance(${1:v1},${2});
snippet prev
	std::prev(${1:v1})
snippet next
	std::next(${1:v1})
snippet advance
	std::advance(${1:v1},${2:N});
snippet accumulate
	std::acumulate(${1}.begin(),$1.end(),${2});
snippet adjacent_find
	std::adjacent_find(${1}.begin(), $1.end());
snippet all_of
	std::all_of(${1}.begin(),$1.end(),${2});
snippet none_of
	std::none_of(${1}.begin(),$1.end(),${2});
snippet any_of
	std::any_of(${1}.begin(),$1.end(),${2});
snippet binary_search
	std::binary_search(${1}.begin(),$1.end(),${2:V});
snippet clamp
	std::clamp(${1:X},${2},${3});
snippet copy
	std::copy(${1:V}.begin(),$1.end(),${2:V1});
snippet copy_n
	std::copy(${1:V}.begin(),${2:N},${3:V1}.begin());
snippet copy_if
	std::copy(${1:V}.begin(),$1.end(),${2:V1},${3});
snippet copy_backward
	std::copy_backward(${1:V}.begin(), $1.end(), ${2:V1}.end());
snippet reverse_copy
	std::reverse_copy(${1:v}.begin(),$1.end(),${2:v1}.begin());
snippet count
	std::count(${1:v}.begin(),$1.end(),${2:v1});
snippet ccount
	${1:vec}.count(${2:value});
snippet count_if
	std::count(${1:v}.begin(),$1.end(),${3:F});
snippet equal
	std::equal(${1:v1}.begin(),$1.end(),${2:v2});
snippet equal_range
	auto [lower,upper] = std::equal_range(${1:sorted}.begin(),$1.end(),${2});
snippet erase
	std::erase(${1:v1},${2:val});
snippet erase_if
	std::erase(${1:v1},${2:func});
snippet cerase
	${1:container}.erase($1.pos1(),$1.optional_iter_pos2());;
	${1:container}.erase(std::remove($1.begin(),$1.end,${2:VAL}),$1.end());
	${1:container}.erase(std::remove_if($1.begin(),$1.end,${2:Func}),$1.end());
snippet fill
	std::fill(${1:v1}.begin(), $1.end(), ${2:N});
snippet fill_n
	std::fill_n(${1:v1}.begin(),${2:N},${3:V});
snippet find
	std::find(${1:v1}.begin(), $1.end(), ${2:V});
snippet cfind
	${1:v}.find(${2:value});
snippet find_if
	std::find(${1:v1}.begin(), $1.end(), ${2:F});
snippet find_if_not
	std::find(${1:v1}.begin(), $1.end(), ${2:F});
snippet find_end
	std::find_end(${1:v1}.begin(),$1.end(),${2:v2}.begin(),$2.end());
snippet find_first_of
	std::find_first_of(${1:v1}.begin(),$1.end(),${2:v2}.begin(),$2.end());
snippet for_each
	std::for_each(${1:v1}.begin(),$1.end(),${2:F});
snippet for_each_n
	std::for_each(${1:v1}.begin(),${2:N},${3:F});
snippet includes
	std::includes(${1:sorted}.begin(),$1.end(),${2:sorted1}.begin(),$2.end(),${3:F});
snippet inner_product
	std::inner_product(${1:v1}.begin(),$1.end(),${2:N});
snippet iota
	std::iota(${1:V}.begin(),$1.end(),${2:N});
snippet insert
	${1:v}.insert(${2:v1},${3:[count]-value-or-range});
snippet iter_swap
	std::iter_swap(${1:X},${2:Y});
snippet lower_bound
	std::lower_bound(${1:sorted1}.begin(),$1.end(),${2:N});
snippet upper_bound
	std::upper_bound(${1:sorted1}.begin(),$1.end(),${2:N});
snippet make_heap
	std::make_heap(${1:V}.begin(),$1.end());
snippet max_element
	std::max_element(${1:v}.begin(),$1.end());
snippet merge
	std::merge(${1:sorted1}.begin(),$1.end(),${2:sorted2}.begin(),$2.end(),${3:sorted3}.begin());
snippet cmerge
	${1:list}.merge(${2:list1});
snippet min_element
	std::min_element(${1:v}.begin(),$1.end());
snippet minmax_element
	auto [min,max] = std::minmax_element(${1:v}.begin,$1.end(),${2:F});
snippet mismatch
	auto [val1,val2] = std::mismatch(${1:v1}.begin(),$1.end(),${2:v2}.begin(),$2.end());
snippet cmove
	std::move(${1:OBJ});
snippet move
	std::move(${1:v1}.begin(),$1.end(),${2:v2}.begin());
snippet move_backward
	std::move_backward(${1:v1}.begin(), $1.end(), ${2:v2}.end());
snippet next_permutation
	std::next_permutation(${1:v1}.begin(),$1.end(),${2:comparator});
snippet prev_permutation
	std::prev_permutation(${1:v1}.begin(),$1.end(),${2:comparator});
snippet nth_element
	std::nth_element(${1:v1}.begin(), $1.begin()+${2:N}, $1.end(), ${3:greater<>()});
snippet partial_sort
	std::partial_sort(${1:v1}.begin(), $1.begin()+${2:N},$1.end());
snippet partition
	auto iter = std::partition(${1}.begin(),$1.end(),${2:func});
snippet partition_copy
	std::partition_copy(${1}.begin(),$1.end(),${2}.begin(),${3}.begin,${4:Func});
snippet remove
	std::remove(${1:v}.begin(),$1.end(),${2:V});
snippet remove_if
	std::remove_if(${1:v}.begin(),$1.end(),${2:F});
snippet remove_copy
	std::remove_copy(${1:v}.begin(),$1.end();${2:v2}.begin(),${3:VAL_REMOVED});
snippet remove_copy_if
	std::remove_copy_if(${1:v}.begin(),$1.end();${2:v2}.begin(),${3:FUNC_REMOVED});
snippet replace
	std::replace(${1:v}.begin(), $1.end(), ${2:OLD},${3:NEW});
snippet replace_if
	std::replace_if(${1:v}.begin(), $1.end(), ${2:FUNC},${3:NEW});
snippet replace_copy
	std::replace_copy(${1:v}.begin(), $1.end(),${2:v1}.begin(), ${3:OLD},${4:NEW});
snippet replace_copy_if
	std::replace_copy_if(${1:v}.begin(), $1.end(),${2:v1}.begin(), ${3:FUNC},${4:NEW});
snippet reverse
	std::reverse(${1:v}.begin(),$1.end());
snippet creverse
	${1:list}.reverse();
snippet rotate
	std::rotate(${1:v}.begin(), $1.begin()+v.size()-${2:N},$1.end());
snippet rotate_copy
	std::rotate_copy(${1:v}.begin(), $1.begin()+${2:N},$1.end(), ${3:v1}.begin());
snippet set_difference
	std::set_difference(${1:sorted1}.begin(),$1.end(),${2:sorted2}.begin(),$2.end(),${3:sorted3}.begin());
snippet set_intersection
	std::set_intersection(${1:sorted1}.begin(),$1.end(),${2:sorted2}.begin(),$2.end(),${3:sorted3}.begin());
snippet set_symmetric_difference
	std::set_symmetric_difference(${1:sorted1}.begin(),$1.end(),${2:sorted2}.begin(),$2.end(),${3:sorted3}.begin());
snippet set_union
	std::set_union(${1:sorted1}.begin(),$1.end(),${2:sorted2}.begin(),$2.end(),${3:sorted3}.begin());
snippet sort
	std::sort(${1}.begin(),$1.end());
snippet csort
	${1:list}.sort();
snippet shift_left
	std::shift_left(${1:v1}.begin(),$1.end(), ${2:N});
snippet shift_right
	std::shift_right(${1:v1}.begin(),$1.end(), ${2:N});
snippet swap
	std::swap(${1:v1},${2:v1});
snippet swap_ranges
	std::swap_ranges(${1:v1}.begin(),$1.end(),${2:v2}.begin());
snippet transform
	std::transform(${1:v1}.begin(),$1.end(),${2:out}.begin(),${3:func});
snippet transformf
	std::transform(${1:v1}.begin(),$1.end(),${2:v2}.begin(),$2.end(),${3:func});
snippet unique
	std::unique(${1:remove_adjacent_duplicates_better_sorted}.begin(),$1.end());
snippet cunique
	${1:list}.unique();
snippet unique_copy
	std::unique_copy(${1:remove_adjacent_duplicates_only_unless_sorted}.begin(),$1.end(),${2:v2}.begin(),${3:optinal_func});
snippet temp
	template<typename ${1}>

snippet scp
	#pragma once
	#include <systemc>
	#include <iostream>

	using namespace sc_core;
	using namespace std;

snippet sch
	#include <systemc>
	#include <iostream>

	using namespace sc_core;
	using namespace std;
snippet scss
	struct $1 : public sc_module {

	};
snippet scs
	SC_MODULE(${1}) {
		${2}
	};
snippet scc
	SC_CTOR(${1}) {
		${2}
	}
snippet scm
	int sc_main(int argc, char *argv[]) {
		${1}

		sc_start();

		return 0;
	}
snippet tlmp
	#pragma once
	#include <tlm>
	#include <iostream>

	using namespace sc_core;
	using namespace sc_dt;
	using namespace std;
	using namespace tlm;

snippet tlmh
	#include <tlm>
	#include <iostream>

	using namespace sc_core;
	using namespace sc_dt;
	using namespace std;
	using namespace tlm;

## NOTE must TAB to indent, can't space!!!
